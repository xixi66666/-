1.单例模式，即单个实例。确保某一个类在内存中只有一个实例，而且自行实例化并向整个系统提供这个实例
    分为饿汉式和懒汉式，同时需要注意懒汉式的线程安全问题。还有枚举单例

2.策略模式：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。
    例如int类型转换成为double类型数据时，也可以使用

3.工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
          任何可以产生对象的方法和类，都可以称之为工厂。工厂模式可以灵活控制生产的过程，如控制权限，增加日志等
    1.工厂方法:假如一个对象的创建，不仅仅包含实例化本身，还需要做大量的初始化操作，如：根据Locale不同，加载不同的国际化文件，并设置其中的值；
    如果这种对象在很多地方使用，那么大量相同且繁琐的处理逻辑，会扩散到项目各个地方；
    简单工厂的每个工厂只创建一个具体类的实例；以方便以后扩展；
        举例：
            任意定制宠物类型：继承yellable()接口
            任意定制生产过程：XXXFactory.create()
            即每一个的类都有一个自己的工厂方法，可以在工厂里面的create方法中灵活增加功能
    2.抽象工厂:为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。解决工厂方法无法创建一组相关对象的缺点
        举例：
            1.我想要定义一个抽象类：人 这个类有三个抽象方法createCountry() createFood() createLanguage()
            2.人有三个属性:食物，国家，语言，所以我分别对这三个属性构建对应的抽象类
            3.之后，我再创建例如china，japan继承国家抽象类，Chinese，Japanese对应语言抽象类  并实现其方法
            4.现在，我就可以定义一个具体工厂继承步骤1中的抽象类了
    工厂方法在扩展单一产品的时候很方便，只需要增加产品工厂就行了，但是比如有多个产品构成产品组的时候就不方便了。
    抽象工厂在扩展产品组的时候很方便，而增加单个产品的时候需要先在抽象工厂中加方法，而后每一个具体工厂都要增加方法。不方便。

4.门面模式 Facade：提供一个统一的接口去访问多个子系统的多个不同的接口，它为子系统中的一组接口提供一个统一的高层接口。使用子系统更容易使用.
                   为了用户使用方便，把过度拆分的分散功能，组合成一个整体，对外提供一个统一的接口
        举例：
            当你有一个业务系统A，它的内部逻辑很复杂（有五个模块互相之间进行调用）。如果有一个外部的系统B需要调用A中的逻辑，这时候的业务代码就会很复杂
            所以需要一个门面来管理A中的模块，B系统只需要与这个门面进行交互就行了，不需要知道这个门面里面的A的所有的逻辑

5.调停者模式 Mediator ：当你有一个业务系统A，它的内部逻辑很复杂（有五个模块互相之间进行调用）。这时候五个模块之间很复杂。
                所以考虑，如果这五个模块中间有一个调停者，调停者与所有模块都互相交互，所有模块把消息都给调停者，调停者来进行消息的分发。
                这时候各个模块之间就没有了复杂的逻辑了。
                具体实现案例：MQ

6.装饰器模式 Decorator Pattern : 某些情况，当一个类已经存在，并且可以对外提供核心功能时，但是，某个时刻，希望对这个类进行功能增强（如：增加缓存）
                               通常情况，我们可以修改原来的类，并增加对应的增强功能即可；但是，这种方式违背了“开-闭”原则，需要修改原来的代码；而且不够灵活，
                               如果有某个时刻又不想使用缓存，又需要修改原来的代码，显然，这不是一个很好的解决方案。
        本质： 引入一个中介类，这个类实现了被装饰者相同的接口，对外假装成被装饰者，并通过引用被装饰者，在调用被装饰者前后做一些附加功能（如：缓存，参数预处理）。
        不修改原来代码的情况下，动态地给一个对象添加一些额外的职责和功能。
        举例：
            1.引入中介对象
            2.中介对象实现被装饰类的接口（对外假装成被装饰类）
            3.中介对象内部引用被装饰类（并把真实功能委托给被装饰对象）；
            4.中介对象在调用被装饰对象前后：增加特殊功能

        装饰器模式侧重的是对功能的增强，不改变原功能
        代理模式侧重于对原功能的改变

7.责任链模式 chain of responsibility : 当有些业务逻辑，比如用户上传的内容需要审核，就有一个上传到审核到入库的过程。
        这时候就有了一个责任链，比如有多个Filter来进行过滤，可以用List进行存储，然后就开始遍历过滤
        内容 ---> filter1 ---> filter2 ---> filter ---> database

8. 观察者模式(时间处理模型) Observer : 它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。
                                  这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。