1.单例模式，即单个实例。确保某一个类在内存中只有一个实例，而且自行实例化并向整个系统提供这个实例
    分为饿汉式和懒汉式，同时需要注意懒汉式的线程安全问题。还有枚举单例

2.策略模式：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。
    例如int类型转换成为double类型数据时，也可以使用

3.工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
          任何可以产生对象的方法和类，都可以称之为工厂。工厂模式可以灵活控制生产的过程，如控制权限，增加日志等
    1.简单工厂:假如一个对象的创建，不仅仅包含实例化本身，还需要做大量的初始化操作，如：根据Locale不同，加载不同的国际化文件，并设置其中的值；
    如果这种对象在很多地方使用，那么大量相同且繁琐的处理逻辑，会扩散到项目各个地方；
        举例：
            任意定制宠物类型：继承yellable()接口
            任意定制生产过程：XXXFactory.create()
            即每一个的类都有一个自己的工厂方法，可以在工厂里面的create方法中灵活增加功能
    2.抽象工厂
        举例：
            1.我想要定义一个抽象类：人 这个类有三个抽象方法createCountry() createFood() createLanguage()
            2.人有三个属性:食物，国家，语言，所以我分别对这三个属性构建对应的抽象类
            3.之后，我再创建例如china，japan继承国家抽象类，Chinese，Japanese对应语言抽象类  并实现其方法
            4.现在，我就可以定义一个具体工厂继承步骤1中的抽象类了
    简单工厂在扩展单一产品的时候很方便，只需要增加产品工厂就行了，但是比如有多个产品构成产品组的时候就不方便了。
    抽象工厂在扩展产品组的时候很方便，而增加单个产品的时候需要先在抽象工厂中加方法，而后每一个具体工厂都要增加方法。不方便。

4.门面模式 Facade：提供一个统一的接口去访问多个子系统的多个不同的接口，它为子系统中的一组接口提供一个统一的高层接口。使用子系统更容易使用
        举例：
            当你有一个业务系统A，它的内部逻辑很复杂（有五个模块互相之间进行调用）。如果有一个外部的系统B需要调用A中的逻辑，这时候的业务代码就会很复杂
            所以需要一个门面来管理A中的模块，B系统只需要与这个门面进行交互就行了，不需要知道这个门面里面的A的所有的逻辑

5.调停者模式 Mediator ：当你有一个业务系统A，它的内部逻辑很复杂（有五个模块互相之间进行调用）。这时候五个模块之间很复杂。
                所以考虑，如果这五个模块中间有一个调停者，调停者与所有模块都互相交互，所有模块把消息都给调停者，调停者来进行消息的分发。
                这时候各个模块之间就没有了复杂的逻辑了。
                具体实现案例：MQ